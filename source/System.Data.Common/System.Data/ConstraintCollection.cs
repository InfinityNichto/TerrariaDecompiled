using System.Collections;
using System.ComponentModel;
using System.Data.Common;
using System.Globalization;

namespace System.Data;

[DefaultEvent("CollectionChanged")]
[Editor("Microsoft.VSDesigner.Data.Design.ConstraintsCollectionEditor, Microsoft.VSDesigner, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public sealed class ConstraintCollection : InternalDataCollectionBase
{
	private readonly DataTable _table;

	private readonly ArrayList _list = new ArrayList();

	private int _defaultNameIndex = 1;

	private CollectionChangeEventHandler _onCollectionChanged;

	private Constraint[] _delayLoadingConstraints;

	private bool _fLoadForeignKeyConstraintsOnly;

	protected override ArrayList List => _list;

	public Constraint this[int index]
	{
		get
		{
			if (index >= 0 && index < List.Count)
			{
				return (Constraint)List[index];
			}
			throw ExceptionBuilder.ConstraintOutOfRange(index);
		}
	}

	internal DataTable Table => _table;

	public Constraint? this[string? name]
	{
		get
		{
			int num = InternalIndexOf(name);
			if (num == -2)
			{
				throw ExceptionBuilder.CaseInsensitiveNameConflict(name);
			}
			if (num >= 0)
			{
				return (Constraint)List[num];
			}
			return null;
		}
	}

	public event CollectionChangeEventHandler? CollectionChanged
	{
		add
		{
			_onCollectionChanged = (CollectionChangeEventHandler)Delegate.Combine(_onCollectionChanged, value);
		}
		remove
		{
			_onCollectionChanged = (CollectionChangeEventHandler)Delegate.Remove(_onCollectionChanged, value);
		}
	}

	internal ConstraintCollection(DataTable table)
	{
		_table = table;
	}

	public void Add(Constraint constraint)
	{
		Add(constraint, addUniqueWhenAddingForeign: true);
	}

	internal void Add(Constraint constraint, bool addUniqueWhenAddingForeign)
	{
		if (constraint == null)
		{
			throw ExceptionBuilder.ArgumentNull("constraint");
		}
		Constraint constraint2 = FindConstraint(constraint);
		if (constraint2 != null)
		{
			throw ExceptionBuilder.DuplicateConstraint(constraint2.ConstraintName);
		}
		if (1 < _table.NestedParentRelations.Length && !AutoGenerated(constraint))
		{
			throw ExceptionBuilder.CantAddConstraintToMultipleNestedTable(_table.TableName);
		}
		if (constraint is UniqueConstraint)
		{
			if (((UniqueConstraint)constraint)._bPrimaryKey && Table._primaryKey != null)
			{
				throw ExceptionBuilder.AddPrimaryKeyConstraint();
			}
			AddUniqueConstraint((UniqueConstraint)constraint);
		}
		else if (constraint is ForeignKeyConstraint)
		{
			ForeignKeyConstraint foreignKeyConstraint = (ForeignKeyConstraint)constraint;
			if (addUniqueWhenAddingForeign)
			{
				UniqueConstraint uniqueConstraint = foreignKeyConstraint.RelatedTable.Constraints.FindKeyConstraint(foreignKeyConstraint.RelatedColumnsReference);
				if (uniqueConstraint == null)
				{
					if (constraint.ConstraintName.Length == 0)
					{
						constraint.ConstraintName = AssignName();
					}
					else
					{
						RegisterName(constraint.ConstraintName);
					}
					uniqueConstraint = new UniqueConstraint(foreignKeyConstraint.RelatedColumnsReference);
					foreignKeyConstraint.RelatedTable.Constraints.Add(uniqueConstraint);
				}
			}
			AddForeignKeyConstraint((ForeignKeyConstraint)constraint);
		}
		BaseAdd(constraint);
		ArrayAdd(constraint);
		OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Add, constraint));
		if (constraint is UniqueConstraint && ((UniqueConstraint)constraint)._bPrimaryKey)
		{
			Table.PrimaryKey = ((UniqueConstraint)constraint).ColumnsReference;
		}
	}

	public Constraint Add(string? name, DataColumn[] columns, bool primaryKey)
	{
		UniqueConstraint uniqueConstraint = new UniqueConstraint(name, columns);
		Add(uniqueConstraint);
		if (primaryKey)
		{
			Table.PrimaryKey = columns;
		}
		return uniqueConstraint;
	}

	public Constraint Add(string? name, DataColumn column, bool primaryKey)
	{
		UniqueConstraint uniqueConstraint = new UniqueConstraint(name, column);
		Add(uniqueConstraint);
		if (primaryKey)
		{
			Table.PrimaryKey = uniqueConstraint.ColumnsReference;
		}
		return uniqueConstraint;
	}

	public Constraint Add(string? name, DataColumn primaryKeyColumn, DataColumn foreignKeyColumn)
	{
		ForeignKeyConstraint foreignKeyConstraint = new ForeignKeyConstraint(name, primaryKeyColumn, foreignKeyColumn);
		Add(foreignKeyConstraint);
		return foreignKeyConstraint;
	}

	public Constraint Add(string? name, DataColumn[] primaryKeyColumns, DataColumn[] foreignKeyColumns)
	{
		ForeignKeyConstraint foreignKeyConstraint = new ForeignKeyConstraint(name, primaryKeyColumns, foreignKeyColumns);
		Add(foreignKeyConstraint);
		return foreignKeyConstraint;
	}

	public void AddRange(Constraint[]? constraints)
	{
		if (_table.fInitInProgress)
		{
			_delayLoadingConstraints = constraints;
			_fLoadForeignKeyConstraintsOnly = false;
		}
		else
		{
			if (constraints == null)
			{
				return;
			}
			foreach (Constraint constraint in constraints)
			{
				if (constraint != null)
				{
					Add(constraint);
				}
			}
		}
	}

	private void AddUniqueConstraint(UniqueConstraint constraint)
	{
		DataColumn[] columnsReference = constraint.ColumnsReference;
		for (int i = 0; i < columnsReference.Length; i++)
		{
			if (columnsReference[i].Table != _table)
			{
				throw ExceptionBuilder.ConstraintForeignTable();
			}
		}
		constraint.ConstraintIndexInitialize();
		if (!constraint.CanEnableConstraint())
		{
			constraint.ConstraintIndexClear();
			throw ExceptionBuilder.UniqueConstraintViolation();
		}
	}

	private void AddForeignKeyConstraint(ForeignKeyConstraint constraint)
	{
		if (!constraint.CanEnableConstraint())
		{
			throw ExceptionBuilder.ConstraintParentValues();
		}
		constraint.CheckCanAddToCollection(this);
	}

	private bool AutoGenerated(Constraint constraint)
	{
		if (constraint is ForeignKeyConstraint fk)
		{
			return XmlTreeGen.AutoGenerated(fk, checkRelation: false);
		}
		UniqueConstraint unique = (UniqueConstraint)constraint;
		return XmlTreeGen.AutoGenerated(unique);
	}

	private void ArrayAdd(Constraint constraint)
	{
		List.Add(constraint);
	}

	private void ArrayRemove(Constraint constraint)
	{
		List.Remove(constraint);
	}

	internal string AssignName()
	{
		string result = MakeName(_defaultNameIndex);
		_defaultNameIndex++;
		return result;
	}

	private void BaseAdd(Constraint constraint)
	{
		if (constraint == null)
		{
			throw ExceptionBuilder.ArgumentNull("constraint");
		}
		if (constraint.ConstraintName.Length == 0)
		{
			constraint.ConstraintName = AssignName();
		}
		else
		{
			RegisterName(constraint.ConstraintName);
		}
		constraint.InCollection = true;
	}

	private void BaseGroupSwitch(Constraint[] oldArray, int oldLength, Constraint[] newArray, int newLength)
	{
		int num = 0;
		for (int i = 0; i < oldLength; i++)
		{
			bool flag = false;
			for (int j = num; j < newLength; j++)
			{
				if (oldArray[i] == newArray[j])
				{
					if (num == j)
					{
						num++;
					}
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				BaseRemove(oldArray[i]);
				List.Remove(oldArray[i]);
			}
		}
		for (int k = 0; k < newLength; k++)
		{
			if (!newArray[k].InCollection)
			{
				BaseAdd(newArray[k]);
			}
			List.Add(newArray[k]);
		}
	}

	private void BaseRemove(Constraint constraint)
	{
		if (constraint == null)
		{
			throw ExceptionBuilder.ArgumentNull("constraint");
		}
		if (constraint.Table != _table)
		{
			throw ExceptionBuilder.ConstraintRemoveFailed();
		}
		UnregisterName(constraint.ConstraintName);
		constraint.InCollection = false;
		if (constraint is UniqueConstraint)
		{
			for (int i = 0; i < Table.ChildRelations.Count; i++)
			{
				DataRelation dataRelation = Table.ChildRelations[i];
				if (dataRelation.ParentKeyConstraint == constraint)
				{
					dataRelation.SetParentKeyConstraint(null);
				}
			}
			((UniqueConstraint)constraint).ConstraintIndexClear();
		}
		else
		{
			if (!(constraint is ForeignKeyConstraint))
			{
				return;
			}
			for (int j = 0; j < Table.ParentRelations.Count; j++)
			{
				DataRelation dataRelation2 = Table.ParentRelations[j];
				if (dataRelation2.ChildKeyConstraint == constraint)
				{
					dataRelation2.SetChildKeyConstraint(null);
				}
			}
		}
	}

	public bool CanRemove(Constraint constraint)
	{
		return CanRemove(constraint, fThrowException: false);
	}

	internal bool CanRemove(Constraint constraint, bool fThrowException)
	{
		return constraint.CanBeRemovedFromCollection(this, fThrowException);
	}

	public void Clear()
	{
		_table.PrimaryKey = null;
		for (int i = 0; i < _table.ParentRelations.Count; i++)
		{
			_table.ParentRelations[i].SetChildKeyConstraint(null);
		}
		for (int j = 0; j < _table.ChildRelations.Count; j++)
		{
			_table.ChildRelations[j].SetParentKeyConstraint(null);
		}
		if (_table.fInitInProgress && _delayLoadingConstraints != null)
		{
			_delayLoadingConstraints = null;
			_fLoadForeignKeyConstraintsOnly = false;
		}
		int count = List.Count;
		Constraint[] array = new Constraint[List.Count];
		List.CopyTo(array, 0);
		try
		{
			BaseGroupSwitch(array, count, Array.Empty<Constraint>(), 0);
		}
		catch (Exception e) when (ADP.IsCatchableOrSecurityExceptionType(e))
		{
			BaseGroupSwitch(Array.Empty<Constraint>(), 0, array, count);
			List.Clear();
			for (int k = 0; k < count; k++)
			{
				List.Add(array[k]);
			}
			throw;
		}
		List.Clear();
		OnCollectionChanged(InternalDataCollectionBase.s_refreshEventArgs);
	}

	public bool Contains(string? name)
	{
		return InternalIndexOf(name) >= 0;
	}

	internal bool Contains(string name, bool caseSensitive)
	{
		if (!caseSensitive)
		{
			return Contains(name);
		}
		int num = InternalIndexOf(name);
		if (num < 0)
		{
			return false;
		}
		return name == ((Constraint)List[num]).ConstraintName;
	}

	public void CopyTo(Constraint[] array, int index)
	{
		if (array == null)
		{
			throw ExceptionBuilder.ArgumentNull("array");
		}
		if (index < 0)
		{
			throw ExceptionBuilder.ArgumentOutOfRange("index");
		}
		if (array.Length - index < _list.Count)
		{
			throw ExceptionBuilder.InvalidOffsetLength();
		}
		for (int i = 0; i < _list.Count; i++)
		{
			array[index + i] = (Constraint)_list[i];
		}
	}

	internal Constraint FindConstraint(Constraint constraint)
	{
		int count = List.Count;
		for (int i = 0; i < count; i++)
		{
			if (((Constraint)List[i]).Equals(constraint))
			{
				return (Constraint)List[i];
			}
		}
		return null;
	}

	internal UniqueConstraint FindKeyConstraint(DataColumn[] columns)
	{
		int count = List.Count;
		for (int i = 0; i < count; i++)
		{
			if (List[i] is UniqueConstraint { Key: var key } uniqueConstraint && CompareArrays(key.ColumnsReference, columns))
			{
				return uniqueConstraint;
			}
		}
		return null;
	}

	internal UniqueConstraint FindKeyConstraint(DataColumn column)
	{
		int count = List.Count;
		for (int i = 0; i < count; i++)
		{
			if (List[i] is UniqueConstraint { Key: var key } uniqueConstraint && key.ColumnsReference.Length == 1 && uniqueConstraint.Key.ColumnsReference[0] == column)
			{
				return uniqueConstraint;
			}
		}
		return null;
	}

	internal ForeignKeyConstraint FindForeignKeyConstraint(DataColumn[] parentColumns, DataColumn[] childColumns)
	{
		int count = List.Count;
		for (int i = 0; i < count; i++)
		{
			if (List[i] is ForeignKeyConstraint { ParentKey: var parentKey } foreignKeyConstraint && CompareArrays(parentKey.ColumnsReference, parentColumns) && CompareArrays(foreignKeyConstraint.ChildKey.ColumnsReference, childColumns))
			{
				return foreignKeyConstraint;
			}
		}
		return null;
	}

	private static bool CompareArrays(DataColumn[] a1, DataColumn[] a2)
	{
		if (a1.Length != a2.Length)
		{
			return false;
		}
		for (int i = 0; i < a1.Length; i++)
		{
			bool flag = false;
			for (int j = 0; j < a2.Length; j++)
			{
				if (a1[i] == a2[j])
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return false;
			}
		}
		return true;
	}

	public int IndexOf(Constraint? constraint)
	{
		if (constraint != null)
		{
			int count = Count;
			for (int i = 0; i < count; i++)
			{
				if (constraint == (Constraint)List[i])
				{
					return i;
				}
			}
		}
		return -1;
	}

	public int IndexOf(string? constraintName)
	{
		int num = InternalIndexOf(constraintName);
		if (num >= 0)
		{
			return num;
		}
		return -1;
	}

	internal int InternalIndexOf(string constraintName)
	{
		int num = -1;
		if (constraintName != null && 0 < constraintName.Length)
		{
			int count = List.Count;
			int num2 = 0;
			for (int i = 0; i < count; i++)
			{
				Constraint constraint = (Constraint)List[i];
				switch (NamesEqual(constraint.ConstraintName, constraintName, fCaseSensitive: false, _table.Locale))
				{
				case 1:
					return i;
				case -1:
					num = ((num == -1) ? i : (-2));
					break;
				}
			}
		}
		return num;
	}

	private string MakeName(int index)
	{
		if (1 == index)
		{
			return "Constraint1";
		}
		return "Constraint" + index.ToString(CultureInfo.InvariantCulture);
	}

	private void OnCollectionChanged(CollectionChangeEventArgs ccevent)
	{
		_onCollectionChanged?.Invoke(this, ccevent);
	}

	internal void RegisterName(string name)
	{
		int count = List.Count;
		for (int i = 0; i < count; i++)
		{
			if (NamesEqual(name, ((Constraint)List[i]).ConstraintName, fCaseSensitive: true, _table.Locale) != 0)
			{
				throw ExceptionBuilder.DuplicateConstraintName(((Constraint)List[i]).ConstraintName);
			}
		}
		if (NamesEqual(name, MakeName(_defaultNameIndex), fCaseSensitive: true, _table.Locale) != 0)
		{
			_defaultNameIndex++;
		}
	}

	public void Remove(Constraint constraint)
	{
		if (constraint == null)
		{
			throw ExceptionBuilder.ArgumentNull("constraint");
		}
		if (CanRemove(constraint, fThrowException: true))
		{
			BaseRemove(constraint);
			ArrayRemove(constraint);
			if (constraint is UniqueConstraint && ((UniqueConstraint)constraint).IsPrimaryKey)
			{
				Table.PrimaryKey = null;
			}
			OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Remove, constraint));
		}
	}

	public void RemoveAt(int index)
	{
		Constraint constraint = this[index];
		if (constraint == null)
		{
			throw ExceptionBuilder.ConstraintOutOfRange(index);
		}
		Remove(constraint);
	}

	public void Remove(string name)
	{
		Constraint constraint = this[name];
		if (constraint == null)
		{
			throw ExceptionBuilder.ConstraintNotInTheTable(name);
		}
		Remove(constraint);
	}

	internal void UnregisterName(string name)
	{
		if (NamesEqual(name, MakeName(_defaultNameIndex - 1), fCaseSensitive: true, _table.Locale) != 0)
		{
			do
			{
				_defaultNameIndex--;
			}
			while (_defaultNameIndex > 1 && !Contains(MakeName(_defaultNameIndex - 1)));
		}
	}

	internal void FinishInitConstraints()
	{
		if (_delayLoadingConstraints == null)
		{
			return;
		}
		for (int i = 0; i < _delayLoadingConstraints.Length; i++)
		{
			int num;
			DataColumn[] array;
			if (_delayLoadingConstraints[i] is UniqueConstraint)
			{
				if (_fLoadForeignKeyConstraintsOnly)
				{
					continue;
				}
				UniqueConstraint uniqueConstraint = (UniqueConstraint)_delayLoadingConstraints[i];
				if (uniqueConstraint._columnNames == null)
				{
					Add(uniqueConstraint);
					continue;
				}
				num = uniqueConstraint._columnNames.Length;
				array = new DataColumn[num];
				for (int j = 0; j < num; j++)
				{
					array[j] = _table.Columns[uniqueConstraint._columnNames[j]];
				}
				if (uniqueConstraint._bPrimaryKey)
				{
					if (_table._primaryKey != null)
					{
						throw ExceptionBuilder.AddPrimaryKeyConstraint();
					}
					Add(uniqueConstraint.ConstraintName, array, primaryKey: true);
				}
				else
				{
					UniqueConstraint constraint = new UniqueConstraint(uniqueConstraint._constraintName, array);
					if (FindConstraint(constraint) == null)
					{
						Add(constraint);
					}
				}
				continue;
			}
			ForeignKeyConstraint foreignKeyConstraint = (ForeignKeyConstraint)_delayLoadingConstraints[i];
			if (foreignKeyConstraint._parentColumnNames == null || foreignKeyConstraint._childColumnNames == null)
			{
				Add(foreignKeyConstraint);
				continue;
			}
			if (_table.DataSet == null)
			{
				_fLoadForeignKeyConstraintsOnly = true;
				continue;
			}
			num = foreignKeyConstraint._parentColumnNames.Length;
			array = new DataColumn[num];
			DataColumn[] array2 = new DataColumn[num];
			for (int k = 0; k < num; k++)
			{
				if (foreignKeyConstraint._parentTableNamespace == null)
				{
					array[k] = _table.DataSet.Tables[foreignKeyConstraint._parentTableName].Columns[foreignKeyConstraint._parentColumnNames[k]];
				}
				else
				{
					array[k] = _table.DataSet.Tables[foreignKeyConstraint._parentTableName, foreignKeyConstraint._parentTableNamespace].Columns[foreignKeyConstraint._parentColumnNames[k]];
				}
				array2[k] = _table.Columns[foreignKeyConstraint._childColumnNames[k]];
			}
			ForeignKeyConstraint foreignKeyConstraint2 = new ForeignKeyConstraint(foreignKeyConstraint._constraintName, array, array2);
			foreignKeyConstraint2.AcceptRejectRule = foreignKeyConstraint._acceptRejectRule;
			foreignKeyConstraint2.DeleteRule = foreignKeyConstraint._deleteRule;
			foreignKeyConstraint2.UpdateRule = foreignKeyConstraint._updateRule;
			Add(foreignKeyConstraint2);
		}
		if (!_fLoadForeignKeyConstraintsOnly)
		{
			_delayLoadingConstraints = null;
		}
	}
}
